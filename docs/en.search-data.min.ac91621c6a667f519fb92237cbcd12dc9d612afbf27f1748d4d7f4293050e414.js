'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href','section'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/docs/overview/','title':"Overview",'section':"Docs",'content':"Overview #  This guide describes how to use the specs, including *.service.spec, *.type.spec file syntax.\nWe will use µSpec notation when it makes no difference or it is easier to use.\nThe standard notation is then used when the µSpec notation does not cover the feature.\nFor a better understanding and when possible the µSpec, spec and the resulting proto will be shown.\n This is a reference guide – for a step by step example, see the tutorials or sample projects.\nThe pages Defining a type , Defining a service and Style Guide should give you enough information for a brief overview. Most of the other pages are detailed topics and can be read later or by interest or need.\nIf you have specified additional commands and flows in your furo config, make sure you install the corresponding dependencies too.\nWhat is Generated From Your specs? #  protos #  First of all, protos and therfore all you can generate with protos.\nThis is done with the following commands.\n furo genMessageProtos - Generate the message protos from the type specs. furo genServiceProtos - Generate service protos from the specs  client environment (es6) #  The client types as es6 module which can be consumed by @furo/furo-data* and various web components of furo. This module allows the usage of the same types on the backend side and in the browser.\n furo genEsModule - generate es6 spec module  Validators, DB Shemas, Custom Documentation,\u0026hellip; #  With furoc, which has a lot of similarities with protoc, you can easyli write your custom generators. The main benefit is that you have a much higher information density then you have with the protos alone (to be fair, you can have the same information density with protos too, but this is not so trivial). The input format for a furoc generator is a yaml structure with your services and types. The output format is the same like in protoc.\nUser Interface Components #  Yes, you have read it correctly. You can generate web-components that you can use in your web projects. At the moment you can do that with @furo/ui-builder. A furoc based version is in development and comming soon.\nREST APIs indirect #  This is done by using the protos with protoc-gen-grpc-gateway.\n1 2 3 4 5  protoc -I . --grpc-gateway_out ./gen/go \\  --grpc-gateway_opt logtostderr=true \\  --grpc-gateway_opt paths=source_relative \\  --grpc-gateway_opt grpc_api_configuration=path/to/config.yaml \\  your/service/v1/your_service.proto   Open Api Specifications indirect #   Open Api aka swagger can be used for various things.\nGenerating Open Api Specifications is done by using the generated protos with protoc-gen-openapiv2.\n1  protoc -I . --openapiv2_out ./gen/openapiv2 --openapiv2_opt logtostderr=true your/service/v1/your_service.proto   Various Clients and Servers indirect #  By using the swagger files on https://editor.swagger.io/ you can generate server and client code for different languages and architectures. You do not have to write the backend as grpc service to work with the furo client framework.\nImporting proto Messages #  You can import your existing proto messages with the protoc-gen-furo-specs protoc plugin. After running Furo, you should receive the same proto file (proto3).\nfuroc #   Furoc is the compiler/transpiler for the specs.\nFuroc will pass a yaml structure with the current config of the spec project, the types, the services, the installed types (dependencies) and the installed services (dependencies) to the generators.\nRelated Documents #    Anatomy of a µType spec  Anatomy of a µService spec  Anatomy of a type spec  Anatomy of a service spec  Good to Read #  [API Design Guide from google #  The API Design Guide from google gives you a good guideline for designing your APIs.\nProtocol Buffers #  This page gives you a good overview on Protocol Buffers.\ngRPC #  This site grpc.io gives you a good entry point to grpc itself.\n"});index.add({'id':1,'href':'/docs/overview/define_type/','title':"Defining a Type",'section':"Overview",'content':"Defining A Type #  Furo types are organized in packages, you can have as many types per package as you want.\nLets do a simple example in µSpec and spec and see what the resulting proto will be.\nDefine the type in µSpec #  The following example is a complete type definition. You can use every type from your specs and installed dependencies. You do not need to import them. The imports are resolved and checked by Furo when you translate your µSecs to standard specs with the command furo muSpec2spec.\nFile: muspec/auth/auth.types.yaml\n1 2 3 4 5  - type:\u0026#39;auth.Credentials #Credentials type for login.\u0026#39;fields:password:\u0026#39;* string:1 #The password.\u0026#39;username:\u0026#39;* string:2 #The username or email, or something to identify.\u0026#39;second_factor:\u0026#39;string:3 #A second factor like TOTP.\u0026#39;  It helps a lot to know the anatomy of a µSpec, read more here\nDefine the type in standard spec #  The standard specs have a much higher information density then the µSpecs. Furo will fill out as much as possible with good defaults by using the .furo configuration file.\nIt helps a lot to know the anatomy of a standard spec, read more here\nFile: specs/auth/Credentials.type.spec\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  name:Credentialstype:Credentialsdescription:Credentials type for login.__proto:package:authtargetfile:auth.protoimports:[]options:go_package:github.com/foo/bar/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.authfields:password:type:stringdescription:The password.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:component:\u0026#34;\u0026#34;flags:[]noinit:falsenoskip:falsemeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:auth.Credentials.password.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:password is requiredusername:type:stringdescription:The username or email, or something to identify.__proto:number:2oneof:\u0026#34;\u0026#34;__ui:component:\u0026#34;\u0026#34;flags:[]noinit:falsenoskip:falsemeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:label.Credentials.usernameoptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:username is requiredsecond_factor:type:stringdescription:A second factor like TOTP.__proto:number:3oneof:\u0026#34;\u0026#34;__ui:component:\u0026#34;\u0026#34;flags:[]noinit:falsenoskip:falsemeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:label.auth.Credentials.second_factoroptions:nullreadonly:falserepeated:falsetypespecific:nullconstraints:{}  Resulting proto from the type definition #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  // Code generated by furo-proto-gen. DO NOT EDIT. syntax = \u0026#34;proto3\u0026#34;;package auth;option go_package = \u0026#34;github.com/foo/bar/dist/pb/auth;authpb\u0026#34;;option java_multiple_files = true;option java_outer_classname = \u0026#34;AuthProto\u0026#34;;option java_package = \u0026#34;com.auth\u0026#34;;// Credentials type for login. message Credentials { // The password.  string password = 1; // The username or email, or something to identify.  string username = 2; // A second factor like TOTP.  string second_factor = 3;}  Specifying Field Types #  Use the scalar value types from proto3 or types that you have defined or installed.\nYou have always to write the package name (package.Type) too , when you plan to use the furo client framework, even when you are on the same file.  Packages and Name Resolution #   Like in protobuf the type name resolution works like C++: first the innermost scope is searched, then the next-innermost, and so on, with each package considered to be \u0026ldquo;inner\u0026rdquo; to its parent package. A leading \u0026lsquo;.\u0026rsquo; (for example, .foo.bar.Baz) means to start from the outermost scope instead.\nField IDs #  The field IDs are also used for the generated protos as field numbers.\nReserved Fields #  There is no concept for reserved fields at the moment.\n"});index.add({'id':2,'href':'/docs/specs/types/','title':"Types",'section':"Specs",'content':"Anatomy of a type spec #  A type spec consists of 2 main sections (fields and __proto) and some properties on the root.\nname #  This property is deprecated. Fill in the same as you fill in on the property type for compatibility with some old generators.\ntype #  The type of the field without the package name. Write it in CamelCase with a capital letter at the beginning.\n__proto #  The proto section defines some properties to generate the proto files.\n1 2 3 4 5 6 7 8 9  __proto:package:authtargetfile:auth.protoimports:[]options:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseauth  Field package string #  This is the desired proto package name.\nIn proto this is optional, in specs this field is not optional\n You can add an optional package specifier to a .proto file to prevent name clashes between protocol message types.\n  Learn more about packages in protobuf\nField targetfile string #  The name of the proto file. Multiple types can write to the same file, if they belong to the same package. The file will be generated in a folder according to the package.\nA package company.groups with a protofile green.proto and a config target dist/proto will be generated to\ndist/proto/company/groups/green.proto\nField imports []string #  Add imports by hand only if you do not work with Furo chain. Furo will check and fix imports for you.\nThis can be done with the command furo checkImports. Imports that can not be found would be reported.\nImports that are not needed anymore, are removed too.\n1 2 3  imports:- google/type/date.proto- google/type/timeofday.proto  field options map\u0026lt;string, string\u0026gt; #  When needed, you can add options for your protos. This can be something like the following:\n1 2 3 4 5  options:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseauth  Potential pitfall: The value of an option is a string, so write values which should have true as value like this:\njava_multiple_files: \u0026quot;true\u0026quot;\nWhen you write true not as string, the value will not work.\n Fields map\u0026lt;string, Field\u0026gt; #  The most important part of a type spec are the fields. The fields section contains a map with fields. A field itself has the properties type, description, meta, constraints, __ui and __proto.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  password:type:stringdescription:The password.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:auth.Credentials.password.labelplaceholder:xx.xx.xx.xxoptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:password is required  Field type string #  The type of the field. This should be one of the types that you have defined or installed.\nField description string #  It is a good practice to give a good description of the type. This description will go to the generated protos and other generates.\nField meta Meta #  In the meta field you can set additional information for field in your type. Only the field meta.repeated does impact the proto. The options that you set here are thought for the backend and the client. This properties are domain specific and can give instructions for generators, validators or displaying the field.\n1 2 3 4 5 6 7 8 9 10 11  meta:default:\u0026#34;1234\u0026#34;hint:\u0026#34;look at the post-it on your monitor or below the keyboard\u0026#34;label:auth.Credentials.password.labelplaceholder:xx.xx.xx.xxoptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:null  default string #  The default value for the field when you create a new object. Keep in mind that this is a string and should be parsed by your implementation.\nhint string #  This property gives you a hint message. On the furo client libs, this property goes through the translation engine first [optional]. The furo-data-xxx-input components will display this value below the field, when you focus it.\nlabel string #  This property labels the field. On the furo client libs, this property goes through the translation engine first [optional]. The furo-data-xxx-input components will display this value as placeholder (as long the field is empty) and or label (as soon you have some value)\nplaceholder string #  This property labels the field. On the furo client libs, this property goes through the translation engine first [optional]. The furo-data-ui5-xxx components will display this value as placeholder (as long the field is empty).\noptions.flags []string #  options.list []Anything #  readonly bool #  Define the field as readonly. The furo client libs will not send this field on a request by default.\nrepeated bool #  Define the field as repeated. Keep in mind that not all combinations are possible. As an exapmle, if you set oneof in __proto, repeated must be set to false.\ntypespecific: Anything #  Deprecated\nThis is something like a extension point for fields in types. Use the extensionpoint on the field please.\nField constraints map\u0026lt;string, Constraint\u0026gt; #  Static constraints are defined on a per field basis. The client libs would use this information to mark the fields in a form which are not valid. This does not mean that you should not check the data on the server side.\nSide note:\nThe constraint may be overwritten by a server response (with meta.fieldname.constraints:{...}).\n 1 2 3 4 5 6 7 8 9 10 11 12 13  constraints:required:#\u0026lt;-- constraintis:\u0026#34;true\u0026#34;#\u0026lt;-- value as stringmessage:password is required#\u0026lt;-- message to write on constraint violationmax:is:\u0026#34;100\u0026#34;message:not more then 100min:is:\u0026#34;10\u0026#34;message:at least 10step:is:\u0026#34;5\u0026#34;message:incrase by 5 only  You have to parse the is field according to your type when you want to use the spec directly. The client libs sets the constraints to the according input fields where they are expected as string. So nothing is to do there. If you write extended validators for the client, you have to parse the is value too.\nField __proto: Fieldproto #  Define the field id (proto number) and set a oneof group if needed.\n The oneof property in detail\n1 2 3  __proto:number:1oneof:\u0026#34;\u0026#34;  Field __ui: Uiprops #  In this property you will define ui relevant attributes of a field. This information is used by some generators. The idea behind is that you can give hints for your generators.\nThe generator @furo/ui-builder use the component property to generate the input for the field with an explicit component, if this property is not set, it will look for the best matching input component. For a string i.e. a text input will be selected. In the example below we know that we have bigger texts and request a textarea to be used.\n1 2 3 4 5  __ui:{component:furo-data-textarea-inputflags:- fullno_init:false  It depends on your generator what you have to fill in the properties. When your generator requires concrete component names, then you have to write it so. When your generator can handle your \u0026ldquo;intention\u0026rdquo; then a flag big or lot would be all you have to set.\nThe property no_init tells the generator to not build something for this input.\n"});index.add({'id':3,'href':'/docs/%C2%B5Specs/types/','title':"Types",'section':"µSpecs",'content':"Anatomy of a type µSpec #  The µType specs are regular yaml files.\nThe \u0026ldquo;type-object\u0026rdquo; contains 3 fields. The fields type, fields are mandatory, the field target is optional and autogenerated when ommited.\nYou can have as many type definitions per file as you want. It makes sense that you put types in a file, that belongs togehter.\nFile: muspec/sample.types.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  - type:\u0026#39;sample.Sample #A sample type\u0026#39;fields:password:\u0026#39;* string:1 #The password.\u0026#39;username:\u0026#39;* string:2 #The username or email, or something to identify.\u0026#39;details:\u0026#39;sample.Details:3 #Details.\u0026#39;target:sample.proto# this is \u0026#34;optional\u0026#34;, if you omit this, Furo will use the package name (auth)- type:\u0026#39;sample.Details #A sample type\u0026#39;fields:birth_date:\u0026#39;* google.type.Date:1 #The birth date.\u0026#39;weight:\u0026#39;* number:2 #The weight.\u0026#39;age:\u0026#39;- number:3 #Calculated field for displaying the age, because the calculations are very hard.\u0026#39;target:sample.proto   The type line #  1 2 3 4 5 6 7 8 9 10 11 12  - type:\u0026#39;sample.Sample #A sample type\u0026#39;!___! !____||_____! !____________!| | | || | type name || package || description (recomended) begins with a#| | | field name of the type  It is a good practice to give a good description of the type.\nFields #  In the \u0026ldquo;fields-object\u0026rdquo;, what a surprise, you define the fields / attributes of a type.\nminimalistic example\n1 2 3 4 5 6 7 8 9 10 11  fieldname:\u0026#39;* string:2 #The description.\u0026#39;!_______! !_!!____!!_!!________________!| | | | | | | | | description (recomended) begins with a#field name | | | | | field id, indicated by a :| | | type | Indicator for required (*), readonly (-), repeated ([])  example with default value and oneof\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  fieldname:\u0026#39;* string:2 = default value [oneofname] #The description.\u0026#39;!_______! !_!!____!!_!!______________!!__________!!________________!| | | | | | | | | | | | oneof definition in [] || | | | default value (=) || | | | || | | | description (recomended) begins with a#field name | | | | | field id, indicated by a :| | | type | Indicator for required (*), readonly (-), repeated ([])  Fieldname #  The name of the field\nIndicator for required #  If the field is required, type in a *\nIndicator for readonly #  If the field is readonly, type in a -\nIndicator for repeated #  If the field is repeated, type in a []\nType #  Types are the same like in protobuf\nField id #  The field id must be unique, the generated protos use them too\nDefault value #  This does not reflect in the protos.\nOneof definition #  Description #  It is a good practice to give a good description of the type. This description will go to the generated protos and other generates.\n"});index.add({'id':4,'href':'/docs/%C2%B5Specs/','title':"µSpecs",'section':"Docs",'content':"µSpecs #  µSpecs or muSpecs are the short notation format of furo FIDL. If you are just interested in protobuf as output, you can get very far with this format. If you need enums you have add them in the standard spec, but are still able to work with the µSpec for the rest.\nOur main goal is to keep the µSpecs as small/simple as possible.\nThe µSpecs specification was built to make rapid progress in the design of prototypes. However, it has now been shown that they can cover a very wide range of use cases.\n"});index.add({'id':5,'href':'/docs/overview/define_service/','title':"Defining a Service",'section':"Overview",'content':"Defining A Service #  Furo services are organized in packages. They can use all types that you have defined in your project or are installed as dependencies.\nLets do a simple example in µSpec and spec and see what the resulting proto will be.\nDefine the service in µSpec #  The following example is a complete service definition. You can use every type from your specs and installed dependencies. You do not need to import them. The imports are resolved and checked by Furo when you translate your µSecs to standard specs with the command furo muSpec2spec.\nFile: muspec/auth/auth.services.yaml\n1 2 3 4 5 6 7 8  - name:AuthSessiondescription:Login with credentials. The service should set a auth cookie on successful login and delete it on logoutpackage:authtarget:authservice.protoservices:- md: \u0026#39;Create:POST /auth auth.Credentials , google.protobuf.Empty #Login with credentials#A login is nothing else then creating a valid session\u0026#39;- md: \u0026#39;Delete:DELETE /auth google.protobuf.Empty , google.protobuf.Empty#Logout.\u0026#39;  It helps a lot to know the anatomy of a µService, read more here\nDefine the service in standard spec #  The standard specs have a much higher information density then the µSpecs. Furo will fill out as much as possible with good defaults by using the .furo configuration file.\nIt helps a lot to know the anatomy of a standard spec, read more here\nWhen you generate the specs from µSpecs, Furo will generate all required types for the request and response in the same package that you have defined for your service. Furo will try to use the best defaults for the types. You can always edit this pre generated types.\nFile: specs/auth/AuthSession.service.spec\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  name:AuthSessionversion:\u0026#34;\u0026#34;description:Login with credentials. The service should set a auth cookie on successful login and delete it on logoutlifecycle:null__proto:package:authtargetfile:authservice.protoimports:- google/api/annotations.proto- auth/reqmsgs.proto- auth/auth.proto- google/protobuf/empty.protooptions:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthserviceProtojava_package:com.furo.baseauthservices:Create:description:\u0026#39;Login with credentials #A login is nothing else then creating a valid session\u0026#39;data:request:auth.Credentialsresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;Create:POST /auth auth.Credentials , google.protobuf.Empty #Login with credentials#A login is nothing else then creating a valid session\u0026#39;href:/authmethod:POSTrel:createquery:{}rpc_name:CreateAuthSessionDelete:description:Logout.data:request:google.protobuf.Emptyresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;Delete:DELETE /auth google.protobuf.Empty , google.protobuf.Empty#Logout.\u0026#39;href:/authmethod:DELETErel:deletequery:{}rpc_name:DeleteAuthSession  Resulting proto from the service definition #  The service itself #  file: dist/protos/auth/authservice.proto\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  // Code generated by furo. DO NOT EDIT. syntax = \u0026#34;proto3\u0026#34;;package auth;option go_package = \u0026#34;github.com/veith/doit-specs/dist/pb/auth;authpb\u0026#34;;option java_multiple_files = true;option java_outer_classname = \u0026#34;AuthserviceProto\u0026#34;;option java_package = \u0026#34;com.furo.baseauth\u0026#34;;import \u0026#34;auth/auth.proto\u0026#34;;import \u0026#34;auth/reqmsgs.proto\u0026#34;;import \u0026#34;google/api/annotations.proto\u0026#34;;import \u0026#34;google/protobuf/empty.proto\u0026#34;;// Login with credentials. The service should set a auth cookie on successful login and delete it on logout service AuthSession { // Login with credentials #A login is nothing else then creating a valid session  rpc CreateAuthSession (CreateAuthSessionRequest) returns (google.protobuf.Empty){ //Create: POST /auth auth.Credentials , google.protobuf.Empty #Login with credentials #A login is nothing else then creating a valid session  option (google.api.http) = {\tpost: \u0026#34;/auth\u0026#34;\tbody: \u0026#34;body\u0026#34;\t}; } // Logout.  rpc DeleteAuthSession (DeleteAuthSessionRequest) returns (google.protobuf.Empty){ //Delete: DELETE /auth google.protobuf.Empty , google.protobuf.Empty #Logout.  option (google.api.http) = {\tdelete: \u0026#34;/auth\u0026#34;\t\t}; }}  The request messages #  file: dist/protos/auth/reqmsgs.proto\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53  // Code generated by furo-proto-gen. DO NOT EDIT. syntax = \u0026#34;proto3\u0026#34;;package auth;option go_package = \u0026#34;github.com/veith/doit-specs/dist/pb/auth;authpb\u0026#34;;option java_multiple_files = true;option java_outer_classname = \u0026#34;ReqmsgsProto\u0026#34;;option java_package = \u0026#34;com.furo.baseauth\u0026#34;;import \u0026#34;auth/auth.proto\u0026#34;;import \u0026#34;google/protobuf/empty.proto\u0026#34;;// request message for CreateAuthService message CreateAuthServiceRequest {  // Body with auth.Credentials  .auth.Credentials body = 1;}// request message for CreateAuthSession message CreateAuthSessionRequest {  // Body with auth.Credentials  .auth.Credentials body = 1;}// request message for CreateSessionAuthService message CreateSessionAuthServiceRequest {  // Body with auth.Credentials  .auth.Credentials body = 1;}// request message for DeleteAuthService message DeleteAuthServiceRequest {  // Body with google.protobuf.Empty  .google.protobuf.Empty body = 1;}// request message for DeleteAuthSession message DeleteAuthSessionRequest {  // Body with google.protobuf.Empty  .google.protobuf.Empty body = 1;}// request message for DeleteSessionAuthService message DeleteSessionAuthServiceRequest {  // Body with google.protobuf.Empty  .google.protobuf.Empty body = 1;}  "});index.add({'id':6,'href':'/docs/specs/services/','title':"Services",'section':"Specs",'content':"Anatomy of a service spec #  A service spec consists of 2 main sections (services and __proto) and some properties on the root node.\nname #  The type of the service without the package name. Follow the style guide and write it in CamelCase with an initial capital.\nversion #  Put any version information of the service. This field does not affect the URL of the services/methods.\nThis property has just informative character at the moment.\ndescription #  Describe the intention of your service in some sentences. You can ommit this field. Furo will add a default description in the generates “developer was to lazy to give a description”.\nlifecycle #  Lifecycle information for the service. If you set to true, put in a info with an alternative solution and maybe a deadline.\n1 2 3  lifecycle:deprecated:falseinfo:This version is still valid  __proto #  The proto section defines some properties to generate the proto files.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  __proto:package:fruittargetfile:fruitservice.protoimports:- google/api/annotations.proto- fruit/reqmsgs.proto- google/protobuf/empty.proto- fruit/fruit.proto- google/protobuf/field_mask.protooptions:go_package:github.com/veith/doit-specs/dist/pb/fruit;fruitpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:FruitserviceProtojava_package:com.furo.basefruit  Field package string #  This is the desired proto package name, his field is not optional\nField imports []string #  The imports are checked by Furo (missing imports will be added). Additional imports will not be removed (maybe you have to do a import for side effects).\nThis can be done with the command furo checkImports and is done in some other commands too. Imports that can not be found would be reported. So you can check for typos like fruit.FruitCollections which should be a fruit.FruitCollection.\n1 2 3  specs/Fruitservice.service.spec :Import fruit.FruitCollections not found in Service FruitService on param ListFruitService   field options map\u0026lt;string,string\u0026gt; #  When needed, you can add options for your protos. This can be something like the following:\n1 2 3 4 5  options:go_package:github.com/veith/doit-specs/dist/pb/fruit;fruitpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:FruitserviceProtojava_package:com.furo.basefruit  services map\u0026lt;string, service\u0026gt; #  The most important part of a service spec are the services, what a surprise. The service section contains a map with services. The key is the \u0026ldquo;name\u0026rdquo; of the service and usualy something like List, Get, Delete, Create, Update, CustomName. This names are not the rpc_name.\nA service itself has the properties description, data, deeplink, query and rpc_name.\na single service in detail\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  List:description:List fruits with pagination.data:request:google.protobuf.Emptyresponse:fruit.FruitCollectionbodyfield:bodydeeplink:description: \u0026#39;List:GET /fruits google.protobuf.Empty , fruit.FruitCollection#List fruits with pagination.\u0026#39;href:/fruitsmethod:GETrel:listquery:q:description:Use this to search for a fruit.type:stringfilter:description:Use this field to filter the fruits, this is not searching.type:stringorder_by:description:Use this field to specify the ordering.type:stringpage:description:Use this field to specify page to display.type:stringrpc_name:ListFruits  Field description string #  It is a good practice to give a good description of the type. This description will go to the generated protos and other generates.\nField data Servicereqres #  Data contains the repuest and response types for the service.\n1 2 3 4  data:request:google.protobuf.Emptyresponse:fruit.FruitCollectionbodyfield:body  request string #  Define the request type. Use google.protobuf.Empty if not needed.\nresponse string #  Define the response type. Use google.protobuf.Empty if not needed.\nbodyfield string #  This defines the body field in request the type The name of the request field whose value is mapped to the HTTP request body, or * for mapping all request fields not captured by the path pattern to the HTTP body, or omitted for not having any HTTP request body.\nNOTE: the referred field must be present at the top-level of the request message type.\nField deeplink Servicedeeplink #  General URL Paht information for the service.\ndeeplink for GetFruit\n1 2 3 4 5  deeplink:description: \u0026#39;Get:GET /fruits/{fr} google.protobuf.Empty , fruit.FruitEntity#Returns a single fruit.\u0026#39;href:/fruits/{fr}method:GETrel:self  description string #  Writing something like \u0026lsquo;Get: GET /fruits/{fr} google.protobuf.Empty , fruit.FruitEntity #Returns a single fruit.\u0026rsquo; is a good idea. Give additional information for the dev. if needed.\nhref string #  The URL pattern with placeholders, like /fruits/{fr} the service is listening to .\nThe placeholders are defined in the request types.\nmethod string #  The request method/verb the service is listening to.\nThis should be one of the following verbs:\n GET PUT PATCH POST DELETE  Side note: If you set the verb to PUT and add a field update_mask of type google.protobuf.FieldMask to the request type update_mask: 'google.protobuf.FieldMask #Needed to patch a record' , an additional binding for the PATCH verb will be created in the proto. Because it is assumable that your service has patch and put capabilities.  rel string #  Give an according relation type for your link. For GET on entities this is usualy a self and on collections a list. For DELETE a rel delete is set. And on custom methods it is mostly the name of the custom method.\nUse lowercase for the rel.\nField query Queryparam #  The query params for this service. This fields are used by the client lib to proove the capabilities of the service. Furo will update this list for you, when you come from µSpec. In near future this will be removed, because the information is already available in the request type and must not be written twice.\nA query param consist of a descritpion for the documentation and a type.\n1 2 3 4 5 6 7  query:q:description:Use this to search for a fruit.type:stringfilter:description:Use this field to filter the fruits, this is not searching.type:string  The types and their values must be url safe. They will appear in the query string of the request.  Field rpc_name string #  The rpc name which should appear in the proto. In the example below you can see that the rpc_name was set to CreateFruit\n1 2 3 4 5 6 7 8 9 10 11 12  service FruitService { // Use this to create new fruits.  rpc CreateFruit (CreateFruitRequest) returns (google.protobuf.Empty){\t//Create: POST /fruits fruit.Fruit , google.protobuf.Empty #Use this to create new fruits. \toption (google.api.http) = {\tpost: \u0026#34;/fruits\u0026#34;\tbody: \u0026#34;body\u0026#34;\t}; }}  Example of a \u0026ldquo;Complete\u0026rdquo; Service #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142  name:FruitServiceversion:\u0026#34;\u0026#34;description:|Fruits are healthy, so having a service which can list some fruits would be nice. We do not cover all fruits, but some. The list will grow with time, hopefully.lifecycle:null__proto:package:fruittargetfile:fruitservice.protoimports:- google/api/annotations.proto- fruit/reqmsgs.proto- google/protobuf/empty.proto- fruit/fruit.proto- google/protobuf/field_mask.protooptions:go_package:github.com/veith/doit-specs/dist/pb/fruit;fruitpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:FruitserviceProtojava_package:com.furo.basefruitservices:List:description:List fruits with pagination.data:request:google.protobuf.Emptyresponse:fruit.FruitCollectionbodyfield:bodydeeplink:description: \u0026#39;List:GET /fruits google.protobuf.Empty , fruit.FruitCollection#List fruits with pagination.\u0026#39;href:/fruitsmethod:GETrel:listquery:q:description:Use this to search for a fruit.type:stringfilter:description:Use this field to filter the fruits, this is not searching.type:stringorder_by:description:Use this field to specify the ordering.type:stringpage:description:Use this field to specify page to display.type:stringrpc_name:ListFruitsGet:description:Returns a single fruit.data:request:google.protobuf.Emptyresponse:fruit.FruitEntitybodyfield:bodydeeplink:description: \u0026#39;Get:GET /fruits/{fr} google.protobuf.Empty , fruit.FruitEntity#Returns a single fruit.\u0026#39;href:/fruits/{fr}method:GETrel:selfquery:fr:description:The query param fr stands for FR id.type:stringrpc_name:GetFruitCreate:description:Use this to create new fruits.data:request:fruit.Fruitresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;Create:POST /fruits fruit.Fruit , google.protobuf.Empty#Use this to create new fruits.\u0026#39;href:/fruitsmethod:POSTrel:createquery:{}rpc_name:CreateFruitUpdate:description:Use this to update existing fruits.data:request:fruit.Fruitresponse:fruit.FruitEntitybodyfield:bodydeeplink:description: \u0026#39;Update:PUT /fruits/{fr} fruit.Fruit , fruit.FruitEntity#Use this to update existing fruits.\u0026#39;href:/fruits/{fr}method:PUTrel:updatequery:fr:description:fr string.type:stringupdate_mask:description:Needed to patch a recordtype:google.protobuf.FieldMaskrpc_name:UpdateFruitDelete:description:Use this to delete existing fruits.data:request:google.protobuf.Emptyresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;Delete:DELETE /fruits/{fr} google.protobuf.Empty , google.protobuf.Empty#Use this to delete existing fruits.\u0026#39;href:/fruits/{fr}method:DELETErel:deletequery:fr:description:fr string.type:stringrpc_name:DeleteFruitDeleteAll:description:Use this to delete ALL fruits.data:request:google.protobuf.Emptyresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;DeleteAll:DELETE /fruits google.protobuf.Empty , google.protobuf.Empty#Use this to delete ALL fruits.\u0026#39;href:/fruitsmethod:DELETErel:deleteallquery:{}rpc_name:DeleteAllFruitsFerment:description:Fermented fruits tastes very good in liquid form.data:request:google.protobuf.Emptyresponse:google.protobuf.Emptybodyfield:bodydeeplink:description: \u0026#39;Ferment:POST /fruits/{fr}:ferment google.protobuf.Empty , google.protobuf.Empty#Custom methods are always POST.\u0026#39;href:/fruits/{fr}:fermentmethod:POSTrel:fermentquery:fr:description:fr is the placeholder for the fruit id.type:stringrpc_name:FermentFruit  "});index.add({'id':7,'href':'/docs/%C2%B5Specs/services/','title':"Services",'section':"µSpecs",'content':"Anatomy of a service µSpec #  The µService specs are regular yaml files.\nThe “service-object” contains 5 fields. The fields name, package and methods are mandatory, the field target and description is optional and autogenerated when ommited.\nYou can have as many service definitions per file as you want. It makes sense that you put types in a file, that belongs togehter.\nThe field methods in µServcies will translate to services in the standard notation for compatibility reasons, because the standard notation is some years old and changing this would be a breaking change we do not want to do at the moment.  1 2 3 4 5 6 7 8 9 10 11  - name:FruitServicedescription:Fruits are healthy, so having a service which can list some fruits would be nice.package:fruittarget:fruit_service.protomethods:- md: \u0026#39;ListFruits:GET /fruits google.protobuf.Empty , fruit.FruitCollection#Filterable and searchable list of fruits with pagination.\u0026#39;qp:q:\u0026#39;string #Use this to search for a fruit.\u0026#39;filter:\u0026#39;string #Use this field to filter the fruits, this is not searching.\u0026#39;order_by:\u0026#39;string #Use this field to specify the ordering.\u0026#39;page:\u0026#39;string #Use this field to specify page to display.\u0026#39;  The Name #  The name of the Service. Visit the style guide for good naming. Can not contain spaces.\nThe Description #  Describe the intention of your service in some sentences. You can ommit this field. Furo will add a default description \u0026ldquo;developer was to lazy to give a description\u0026rdquo;.\nThe Package #  Define the package, this service belongs too.\nThe Target #  The target proto file for the generated proto. Furo can not generate proto files which mixes types and services.\nThe Method definition #  The method defiton is made like the type line in µTypes\n1 2 3 4 5 6 7 8 9 10 11 12 13  methods:- md: \u0026#39;GetFruit:GET /fruits/{frt} google.protobuf.Empty , fruit.FruitCollection#Filterable list of fruits.\u0026#39;^ !______!^ !__! !_____!!__! !___________________! ^ !___________________! ^!________________________!| | | | | | | | | | |this means | | | | | the request type | | | |Method | | | | placeholder | the response type | |Definiton | | | the URL | | descriptionmethod name | a comma |the http verb (#) is a separator, indicating the| beginning of the description |(:) is just a separator  The Method Name #  The method name should follow the naming conventions from the google api design guide. Default names are (with fruit as example)\n ListFruits with a verb GET to receive a list of fruits GetFruit with a verb GET and an identifier placeholder to get a single record UpdateFruit with a verb PUT or PATCH and an identifier placeholder to update a single record CreateFruit with a verb POST to create a single record DeleteFruit with a verb DELETE and an identifier placeholder to delete a single record DeleteAllFruits with a verb DELETE to delete all records on this path CustomMethod with a verb POST to do custom stuff that does not fit in the other methods. Uses always a POST.  The HTTP Verb #  Use the standard Http verbs (GET, PUT, PATCH, POST, DELETE) according to the idempotency, except on custom methods, they should always use POST.\nThe URL with Placeholder #  Usualy the path part is a noun in plural form. Use singular nouns only on singleton ressources. Do not append a prefix like /api to your paths. Use /fruits.\nTIPP: Assume that your API is a host by its own. So you will address it with api.xy.com/fruits. Having api.xy.com/api/fruits will look strange in that moment.\nAdding prefixes can be done by infrastructure. The furo client libs also have the posibillity to prefix your specs according to the situation.\n You will loose portability capabilities when you prefix your paths.  The Request Type #  On GET requests you can not send a body, therfore you will put a google.protobuf.Empty type here. On DELETE requests you can not send a body, therfore you will put a google.protobuf.Empty type here. On the other verbs, set the type to one of the types in your project specs or installed specs.\nThe Response Type #  Usualy you should use a entity or collection type as response (this is what the client libs loves to work with). But you are free to define any response type as long all participants on client and server side know it.\nDescription #  Again, descriptions are always optional, but strongly recomended to fill in. They will apear in every generate and can give good hints to the devs who have to implement the specs.\nThe Query Params #  Methods can have query params as part of the URL path (placeholders) and as query part.\nTIPP: be lazy and just write your /paths/with/{phdr}/fruits/{frt}.\nThen run furo muSrvSanitize.\nThis will add the missing query params to your spec with a default description.\n 1 2 3 4 5 6 7 8  qp:\u0026lt;--- this means QueryParamsq:\u0026#39;string #Use this to search for a fruit.\u0026#39;^ !_____! !______________________________!| | || type description |the name of the query param  The Query Param Name #  The name must match with the used placeholders for the path part. Query params should fullfill the RFC3986. Otherwise you risk to never receive the param on the server side.\nThe Query Param Type #  The type is mostly a string. You can use any type which is url safe.\nThe Query Param Description #  Ceterum censeo, descriptions are useful information.\nCustom Methods in Detail #  todo: write something about that.\n"});index.add({'id':8,'href':'/docs/specs/','title':"Specs",'section':"Docs",'content':"Specs #  The specs or \u0026ldquo;standard specs\u0026rdquo; are the extended notation format of furo FIDL. If you are just interested in protobuf as output, consider to work with µSpecs.\nThe specs have extensionpoints on many places. If you need to add your extension, you have to add them at the extension points now. In older versions of the specs this was experimental, now they are an integral part of the specs.\nThe extensionpoint are ,in simple words, just a map\u0026lt;string,google.protobuf.Any\u0026gt;. Furoc gives you nice helpers to get your extensions in your generators. If you work with js based generators, the only thing that changes is the name.\nTypes #  A type spec in FIDL is compareable to a message in proto and have a lot of similarities.\nWhen you look at a field definition i.e. the only new field to the specs was oneof. The number field was added, because just using the index+1 was not enough.\nThere is a __proto option for the type itself, which defines the\n package targetfile imports options  Services #  A service spec in FIDL is compareable to a proto service definition with option (google.api.http) on every rpc. There is only a __proto extension for the service itself, which defines the\n package targetfile imports options  "});index.add({'id':9,'href':'/docs/overview/default_values/','title':"Default Values",'section':"Overview",'content':"Fields And Default Values #  The client lib will fill the \u0026ldquo;proto\u0026rdquo; default values for the fields when they are not transmited. This means i.e. numeric types will get a 0, strings a empty string. The default value that you can specify in the specs has nothing to do with proto directly. Proto 3 does not know anything about default values.\nThis comes very handy when you create an instance of a type on the client side and pass the data object to a form.\nStatic Default Values #  The standard spec let you define a default value. This values are entered as string and must be parsed by them who use them. The client framework, does the parsing transparently for you.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  fields:description:type:stringdescription:Describe the fruit__proto:number:3oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;This is the default\u0026#34;#\u0026lt;-- default values goes here!hint:\u0026#34;\u0026#34;label:fruit.Fruit.description.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:description is required  Json Object Example #  It is recomended to enter the default values as json string. The javascript clients will not parse them, when you use yaml notation.\n1 2 3 4 5 6 7  fields:fruit:type:fruit.Fruit meta:#the following default value is a string too, it just look like a json object.default:|{\u0026#34;key\u0026#34;:\u0026#34;value\u0026#34;}  Runtime Default Values #  This topic belongs more to the client libs and is here only for completenes.\nYou can set default value for a type on the client side during runtime with a server response via the meta field.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  { \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;scalar_string\u0026#34;: \u0026#34;this is a scalar string\u0026#34; }, \u0026#34;links\u0026#34;: [], \u0026#34;meta\u0026#34;: { \u0026#34;fields\u0026#34;: { \u0026#34;data.scalar_string\u0026#34;: { \u0026#34;meta\u0026#34;: { \u0026#34;label\u0026#34;: \u0026#34;scalar_string string label setted via response meta\u0026#34;, \u0026#34;readonly\u0026#34;: false, \u0026#34;default\u0026#34;: \u0026#34;runtime default value\u0026#34; } } } } }   There are more patterns to feed the clien with default values. It is also possible to build a custom method which creates a default object on the server side and feed this to the data object on the client side to create a new object. Hint: by doing this do not forget to set the HATEOAS link for the rel create.  "});index.add({'id':10,'href':'/docs/specs/enums/','title':"Enums",'section':"Specs",'content':"Anatomy of a enum spec #  A type spec consists of 2 main sections (values and __proto) and some properties on the root.\ntype #  The type of the field without the package name. Write it in CamelCase with a capital letter at the beginning.\n__proto #  The proto section defines some properties to generate the proto files.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  type:Corpusdescription:Description for a enum sample with aliaseslifecycle:null__proto:package:enumstargetfile:enums.protoimports:[]options:go_package:github.com/yourname/sample-specs/dist/pb/enums;enumspbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:Corpus.EnumProtojava_package:com.example.tutorial.enumsallow_alias:truevalues:UNKNOWN:0STARTED:1RUNNING:1COMPLETE:2  sample.enum.spec\nField package string #  This is the desired proto package name.\nIn proto this is optional, in specs this field is not optional\n You can add an optional package specifier to a .proto file to prevent name clashes between protocol message types.\n  Learn more about packages in protobuf\nField targetfile string #  The name of the proto file. Multiple types can write to the same file, if they belong to the same package. The file will be generated in a folder according to the package.\nA package company.groups with a protofile green.proto and a config target dist/proto will be generated to\ndist/proto/company/groups/green.proto\nField imports []string #  Add imports by hand only if you do not work with Furo chain. Furo will check and fix imports for you.\nThis can be done with the command furo checkImports. Imports that can not be found would be reported.\nImports that are not needed anymore, are removed too.\n1 2 3  imports:- google/type/date.proto- google/type/timeofday.proto  field options map\u0026lt;string, string\u0026gt; #  When needed, you can add options for your protos. This can be something like the following:\n1 2 3 4 5  options:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseauth  Potential pitfall: The value of an option is a string, so write values which should have true as value like this:\njava_multiple_files: \u0026quot;true\u0026quot;\nWhen you write true not as string, the value will not work.\n Fields map\u0026lt;string, Field\u0026gt; #  The most important part of a type spec are the fields. The fields section contains a map with fields. A field itself has the properties type, description, meta, constraints, __ui and __proto.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  password:type:stringdescription:The password.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:auth.Credentials.password.labelplaceholder:xx.xx.xx.xxoptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:password is required  Field type string #  The type of the field. This should be one of the types that you have defined or installed.\nField description string #  It is a good practice to give a good description of the type. This description will go to the generated protos and other generates.\nField meta Meta #  In the meta field you can set additional information for field in your type. Only the field meta.repeated does impact the proto. The options that you set here are thought for the backend and the client. This properties are domain specific and can give instructions for generators, validators or displaying the field.\n1 2 3 4 5 6 7 8 9 10 11  meta:default:\u0026#34;1234\u0026#34;hint:\u0026#34;look at the post-it on your monitor or below the keyboard\u0026#34;label:auth.Credentials.password.labelplaceholder:xx.xx.xx.xxoptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:null  default string #  The default value for the field when you create a new object. Keep in mind that this is a string and should be parsed by your implementation.\nhint string #  This property gives you a hint message. On the furo client libs, this property goes through the translation engine first [optional]. The furo-data-xxx-input components will display this value below the field, when you focus it.\nlabel string #  This property labels the field. On the furo client libs, this property goes through the translation engine first [optional]. The furo-data-xxx-input components will display this value as placeholder (as long the field is empty) and or label (as soon you have some value)\nplaceholder string #  This property labels the field. On the furo client libs, this property goes through the translation engine first [optional]. The furo-data-ui5-xxx components will display this value as placeholder (as long the field is empty).\noptions.flags []string #  options.list []Anything #  readonly bool #  Define the field as readonly. The furo client libs will not send this field on a request by default.\nrepeated bool #  Define the field as repeated. Keep in mind that not all combinations are possible. As an exapmle, if you set oneof in __proto, repeated must be set to false.\ntypespecific: Anything #  Deprecated\nThis is something like a extension point for fields in types. Use the extensionpoint on the field please.\nField constraints map\u0026lt;string, Constraint\u0026gt; #  Static constraints are defined on a per field basis. The client libs would use this information to mark the fields in a form which are not valid. This does not mean that you should not check the data on the server side.\nSide note:\nThe constraint may be overwritten by a server response (with meta.fieldname.constraints:{...}).\n 1 2 3 4 5 6 7 8 9 10 11 12 13  constraints:required:#\u0026lt;-- constraintis:\u0026#34;true\u0026#34;#\u0026lt;-- value as stringmessage:password is required#\u0026lt;-- message to write on constraint violationmax:is:\u0026#34;100\u0026#34;message:not more then 100min:is:\u0026#34;10\u0026#34;message:at least 10step:is:\u0026#34;5\u0026#34;message:incrase by 5 only  You have to parse the is field according to your type when you want to use the spec directly. The client libs sets the constraints to the according input fields where they are expected as string. So nothing is to do there. If you write extended validators for the client, you have to parse the is value too.\nField __proto: Fieldproto #  Define the field id (proto number) and set a oneof group if needed.\n The oneof property in detail\n1 2 3  __proto:number:1oneof:\u0026#34;\u0026#34;  Field __ui: Uiprops #  In this property you will define ui relevant attributes of a field. This information is used by some generators. The idea behind is that you can give hints for your generators.\nThe generator @furo/ui-builder use the component property to generate the input for the field with an explicit component, if this property is not set, it will look for the best matching input component. For a string i.e. a text input will be selected. In the example below we know that we have bigger texts and request a textarea to be used.\n1 2 3 4 5  __ui:{component:furo-data-textarea-inputflags:- fullno_init:false  It depends on your generator what you have to fill in the properties. When your generator requires concrete component names, then you have to write it so. When your generator can handle your \u0026ldquo;intention\u0026rdquo; then a flag big or lot would be all you have to set.\nThe property no_init tells the generator to not build something for this input.\n"});index.add({'id':11,'href':'/docs/overview/scalar_value_types/','title':"Scalar Types",'section':"Overview",'content':"Scalar Value Types #  Furo specs knows the same scalar types which are defined in ProtocolBuffers.\n   type note golang java es6     string Please use UTF-8 *string String String   bytes  []byte ByteString String   bool  *bool boolean Boolean   float  *float32 float Number   double  *float64 double Number   int32  *int32 int Number   int64  *int64 long Number   uint32  *uint32 int Number   uint64  *uint64 long Number   sint32  *int32 int Number   sint64  *int64 long Number   fixed32  *uint32 int Number   fixed64  *uint64 long Number   sfixed32  *int32 int Number   sfixed64  *int64 long Number    "});index.add({'id':12,'href':'/docs/overview/using_other_types/','title':"Using Other Types",'section':"Overview",'content':"Using Other Types #  You can use other types as field types. You can use every type from your specs and installed dependencies. You do not need to import them. The imports are resolved and checked by Furo when you translate your µSecs to standard specs with the command furo muSpec2spec or with the command muspec checkImpors.\nBy using types which are not installed in the dependencies or not from your spec project, do not forget to import them in your protoc command with \u0026ldquo;-I\u0026rdquo;.\nWhen you need this types on the client side you also need to import them separately.\n For example, let\u0026rsquo;s say you wanted to include sample.Details in sample.Sample on the field details – to do this, you can define another type in the same type µSpec. In standard spec you have to use 2 files, because the standard spec can only handle 1 type per file due to historical reasons:\nFile: muspec/sample.types.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13  - type:\u0026#39;sample.Sample #A sample type\u0026#39;fields:password:\u0026#39;* string:1 #The password.\u0026#39;username:\u0026#39;* string:2 #The username or email, or something to identify.\u0026#39;details:\u0026#39;sample.Details:3 #Details.\u0026#39;- type:\u0026#39;sample.Details #A sample type\u0026#39;fields:birth_date:\u0026#39;* google.type.Date:1 #The birth date.\u0026#39;weight:\u0026#39;* number:2 #The weight.\u0026#39;age:\u0026#39;- number:3 #Calculated field for displaying the age, because the calculations are very hard.\u0026#39;  "});index.add({'id':13,'href':'/docs/overview/enums/','title':"Enumerations",'section':"Overview",'content':"Enumerations #  Before you can use enums in muSpecs, make sure that you define the globs in your .furo file.\n1 2 3 4  muSpec:enums:# define a set of globs which matches your type definitions- \u0026#34;./muspecs/**/*enums.yaml\u0026#34;- \u0026#34;./muspecs/*enums.yaml\u0026#34;    If you want to use enums with grpc-gateway and the furo-web components, do not forget to set the MarshalOption UseEnumNumbers: true, .\nRead mor about customizing your gateway here.\ncustomized marshaller\n1 2 3 4 5 6 7 8 9 10 11 12  gwruntime.WithMarshalerOption(gwruntime.MIMEWildcard, \u0026amp;marshaller.HTTPBodyMarshaler{ Marshaler: \u0026amp;gwruntime.JSONPb{ MarshalOptions: protojson.MarshalOptions{ UseProtoNames: true, EmitUnpopulated: false, UseEnumNumbers: true, }, UnmarshalOptions: protojson.UnmarshalOptions{ DiscardUnknown: true, }, }, }),     Define enums in µSpec #  You can define multiple enums in a µSpec enum file.\nIt is possible to set the target: to a file which contains messages. It is not possible to mix them with service protos.\n1 2 3 4 5 6 7 8  - enum:\u0026#39;helloworld.Corpus #Description for a enum sample with aliases\u0026#39;values:UNKNOWN:0STARTED:1RUNNING:1COMPLETE:2target:enums.protoalias:true# this is needed when you want to allow aliases  sample.enums.yaml\nAs you can see, the Corpus enum’s first constant maps to zero: every enum definition must contain a constant that maps to zero as its first element. This is needed for the compatibility with protobuf.\nDefine enums in specs #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  type:Corpusdescription:Description for a enum sample with aliaseslifecycle:null__proto:package:helloworldtargetfile:enums.protoimports:[]options:go_package:github.com/yourname/sample-specs/dist/pb/helloworld;helloworldpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:Corpus.EnumProtojava_package:com.example.tutorial.enumsallow_alias:truevalues:UNKNOWN:0STARTED:1RUNNING:1COMPLETE:2  sample.enum.spec\nResulting proto file #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  // Code generated by furo-proto-gen. DO NOT EDIT. syntax = \u0026#34;proto3\u0026#34;;package helloworld;option go_package = \u0026#34;github.com/yourname/sample-specs/dist/pb/helloworld;helloworldpb\u0026#34;;option java_multiple_files = true;option java_outer_classname = \u0026#34;EnumsProto\u0026#34;;option java_package = \u0026#34;com.example.tutorial.enums\u0026#34;;// Description for a enum sample with aliases enum Corpus { UNKNOWN = 0; STARTED = 1; RUNNING = 1; COMPLETE = 2; option allow_alias = true;}  enum.proto\nEnum in ES6Module (web client) #  Because js does not have enums, the fields with a enum type are generated as uint32 with an optionlist in the meta. The furo-ui5-select component can handle this metas.\n"});index.add({'id':14,'href':'/docs/%C2%B5Specs/enums/','title':"Enums",'section':"µSpecs",'content':"Anatomy of a enum µSpec #  The µType specs are regular yaml files.\nThe \u0026ldquo;enum-object\u0026rdquo; contains 4 fields. The fields enum, values are mandatory, the field target and alias are optional.\nYou can have as many enum definitions per file as you want. It makes sense that you put enums in a file, that belongs togehter.\nIt is not possible to mix enums and types in the same µSpec file at the moment.\nFile: muspec/sample.enums.yaml\n1 2 3 4 5 6 7 8  - enum:\u0026#39;helloworld.Corpus #Description for a enum sample with aliases\u0026#39;values:UNKNOWN:0STARTED:1RUNNING:1COMPLETE:2target:enums.protoalias:true# this is needed when you want to allow aliases  As you can see, the Corpus enum\u0026rsquo;s first constant maps to zero: every enum definition must contain a constant that maps to zero as its first element. This is because for the compatibility with protobuf.\nThe enum definition line #  1 2 3 4 5 6 7 8 9 10 11 12  - enum:\u0026#39;sample.Corpus #Description for a enum sample with aliases\u0026#39;!___! !____||_____! !__________________________________________!| | | || | \u0026#34;type\u0026#34; name || package || description (recomended) begins with a#| | | field name to declare a enum  It is a good practice to give a good description.\nValues #  In the \u0026ldquo;values-object\u0026rdquo;, you define the values of the enum.\n1 2 3 4 5 6 7 8 9 10  values:UNKNOWN:0STARTED:1!_____! !_! | | | | constant | | Value  Alias #  Alias is a boolean field to define if you want to allow aliases.\n Read more about aliases here.\nTarget #  In the field target, you can define the target proto file for the enum definition.\n"});index.add({'id':15,'href':'/docs/overview/oneof/','title':"Oneof",'section':"Overview",'content':"Oneof #  If you have a message with many optional fields and where at most one field will be set at the same time.\nIn the client lib, at most one field can be set at the same time. Setting any member of the oneof automatically clears all the other members.\nUsing Oneof #  Just define a name for the oneof.\nfield section of a type µSpec\n1 2 3 4  fields:method:\u0026#39;* string:1 [handler] #The name of the method to call with the wire data. If you want add custom code use source instead of method. /oneof:handler/\u0026#39;source:\u0026#39;* string:2 [handler] #Anonyous method to handle the wire. Prefer the use of method. /oneof:handler/\u0026#39;  field section of a type spec\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  fields:method:type:stringdescription:The name of the method to call with the wire data. If you want add custom code use source instead of method. /oneof:handler/__proto:number:3oneof:handler__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:furo.u33e.WireHook.method.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:{}source:type:stringdescription:Anonyous method to handle the wire. Prefer the use of method. /oneof:handler/__proto:number:4oneof:handler__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:furo.u33e.WireHook.source.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:{}  The resulting proto would be like:\nproto\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  // Wire hooks to connect internal wires with methods. message WireHook {  // Short description what you will do when this wire was triggered  string description = 1; // The wire to hook on.  string wire = 2; // Registers the hook as first receiver of the wire.  bool hookBefore = 5; oneof handler { // The name of the method to call with the wire data. If you want add custom code use source instead of method. /oneof:handler/  string method = 3; // Anonyous method to handle the wire. Prefer the use of method. /oneof:handler/  string source = 4; }}  "});index.add({'id':16,'href':'/docs/overview/maps/','title':"Maps",'section':"Overview",'content':"Maps #  If you want to create an associative map as part of your data definition, you can define them as a field type like any other type.\nThe key of the map can only be a string.  in µSpec #  1 2  fields:properties:\u0026#39;map\u0026lt;string,furo.u33e.Property\u0026gt;:9 #Add properties you want to expose of reflect on your component.\u0026#39;  in spec #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  fields:properties:type:map\u0026lt;string,furo.u33e.Property\u0026gt;description:Add properties you want to expose of reflect on your component.__proto:number:9oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:furo.u33e.U33eModel.properties.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:{}  "});index.add({'id':17,'href':'/docs/overview/streaming/','title':"Streaming",'section':"Overview",'content':"Streaming #  You can do streaming by adding the keyword stream to your response type.\nYou need at least furo 1.24.1 to use this feature  Read more about grpc streaming here\nStreaming big files to the client #  1 2 3  - md: \u0026#39;Get:GET /files/{fid} google.protobuf.Empty , stream google.api.HttpBody#Returns the raw file\u0026#39;qp:fid:\u0026#39;string #The query param fid stands for the id of a file.\u0026#39;  With google.api.HttpBody you can send any content to the client. Read more about google.api.HttpBody here.\nStream a message type #  1  - md: \u0026#39;Get:GET /messagestream google.protobuf.Empty, stream message.Message#Returns a stream of messages\u0026#39;  You also can stream a message type to the client.\nThe response will be packed in a attribute \u0026ldquo;result\u0026rdquo;,  Please read the documentation on the grpc-gateway page for configuring your gateway, or have a look on the example subsite\n"});index.add({'id':18,'href':'/docs/overview/packages/','title':"Packages",'section':"Overview",'content':"Packages #  Packages are not optional in FIDLs. Even when you are in the same µType file, you have to write at least the deepest package name to address another type from the same package.\nPackages in µType are defined in the type field. The package for the type below will be auth.\n1 2 3 4 5  - type:\u0026#39;auth.Credentials #Credentials type for login.\u0026#39;fields:password:\u0026#39;* string:1 #The password.\u0026#39;username:\u0026#39;* string:2 #The username or email, or something to identify.\u0026#39;  Packages in µServices will be defined on the package field.\n1 2 3 4 5 6 7  - name:Authsessiondescription:Login with credentials. The service should set a auth cookie on login and delete it on logoutpackage:authtarget:authservice.protoservices:- md: \u0026#39;Create:POST /auth auth.Credentials , google.protobuf.Empty #Login with credentials#Nimmt die Credentials für die Anmeldung entgegen\u0026#39;- md: \u0026#39;Delete:DELETE /auth google.protobuf.Empty , google.protobuf.Empty#Logout.\u0026#39;  Packages in the specs (types and services) are defined in the field __proto.package .\nNote: The fieldname __proto is due to historical reasons, proto was just an extension in the early days of the furo specs.  1 2  __proto:package:auth  type spec example #  This will result in following spec type, using this config :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  name:Credentialstype:Credentialsdescription:Credentials type for login.__proto:package:authtargetfile:auth.protoimports:[]options:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseauthfields:password:type:stringdescription:The password.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:auth.Credentials.password.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:password is requiredusername:type:stringdescription:The username or email, or something to identify.__proto:number:2oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:auth.Credentials.username.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:username is required   proto example #  The resulting proto will look like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  // Code generated by furo. DO NOT EDIT. syntax = \u0026#34;proto3\u0026#34;;package auth;option go_package = \u0026#34;github.com/veith/doit-specs/dist/pb/auth;authpb\u0026#34;;option java_multiple_files = true;option java_outer_classname = \u0026#34;AuthProto\u0026#34;;option java_package = \u0026#34;com.furo.baseauth\u0026#34;;// Credentials type for login. message Credentials {  // The password.  string password = 1; // The username or email, or something to identify.  string username = 2; }  Packages and Name Resolution #   Like in protobuf the type name resolution works like C++: first the innermost scope is searched, then the next-innermost, and so on, with each package considered to be \u0026ldquo;inner\u0026rdquo; to its parent package. A leading \u0026lsquo;.\u0026rsquo; (for example, .foo.bar.Baz) means to start from the outermost scope instead.\nPackages in µSpes #  By translating µSpecs to specs, furo will refer to the .furo configuration file for your packages. The java and golang packages are added as corresponding option to the specs. Once setted, Furo will not change them again.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  spectools:\u0026#34;1.18.1\u0026#34;module:\u0026#34;github.com/veith/doit-specs\u0026#34;version:\u0026#34;v1.0.0\u0026#34;specDir:\u0026#34;./specs\u0026#34;specFormat:\u0026#34;yaml\u0026#34;#set to yaml or jsondependencies:- \u0026#34;git@github.com:theNorstroem/furoBaseSpecs.git v1.11.8\u0026#34;# The importer looks for all **/*.type.spec files recursive The importer looks for all **/*.service.spec files recursivedependenciesDir:dependenciesmuSpec:types:- \u0026#34;./muspecs/**/*types.yaml\u0026#34;- \u0026#34;./muspecs/*types.yaml\u0026#34;services:- \u0026#34;./muspecs/**/*services.yaml\u0026#34;- \u0026#34;./muspecs/*services.yaml\u0026#34;goPackageBase:\u0026#34;github.com/veith/doit-specs/dist/pb/\u0026#34;#this is used to prefix the go package optionjavaPackagePrefix:\u0026#34;com.furo.base\u0026#34;dir:\u0026#34;muspecs\u0026#34;  "});index.add({'id':19,'href':'/docs/overview/streaming/grpc_gateway/','title':"Example",'section':"Streaming",'content':"Example setup for grpc-gateway #  If you need newline delimited messages and raw streams, define a marhalerOption for the corresponding mimetype.\nExample\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  // import gwruntime \u0026#34;github.com/grpc-ecosystem/grpc-gateway/v2/runtime\u0026#34;  // Do not send x-ndjson for gwruntime.MIMEWildcard (*) \tgwruntime.WithMarshalerOption(gwruntime.MIMEWildcard, \u0026amp;marshaller.HTTPBodyMarshaler{ Marshaler: \u0026amp;gwruntime.JSONPb{ MarshalOptions: protojson.MarshalOptions{ UseProtoNames: true, EmitUnpopulated: false, }, UnmarshalOptions: protojson.UnmarshalOptions{ DiscardUnknown: true, }, }, }), // send newline delimeted json if client sends the corresponding accept type \tgwruntime.WithMarshalerOption(\u0026#34;application/x-ndjson\u0026#34;, \u0026amp;gwruntime.HTTPBodyMarshaler{ Marshaler: \u0026amp;gwruntime.JSONPb{ MarshalOptions: protojson.MarshalOptions{ UseProtoNames: true, EmitUnpopulated: false, }, UnmarshalOptions: protojson.UnmarshalOptions{ DiscardUnknown: true, }, }, }), }   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40  package marshaller import ( \u0026#34;github.com/grpc-ecosystem/grpc-gateway/v2/runtime\u0026#34; \u0026#34;google.golang.org/genproto/googleapis/api/httpbody\u0026#34; ) // HTTPBodyMarshaler is a Marshaler which supports marshaling of a // google.api.HttpBody message as the full response body if it is // the actual message used as the response. If not, then this will // simply fallback to the Marshaler specified as its default Marshaler. type HTTPBodyMarshaler struct { runtime.Marshaler } // ContentType returns its specified content type in case v is a // google.api.HttpBody message, otherwise it will fall back to the default Marshalers // content type. func (h *HTTPBodyMarshaler) ContentType(v interface{}) string { if httpBody, ok := v.(*httpbody.HttpBody); ok { return httpBody.GetContentType() } return h.Marshaler.ContentType(v) } // Marshal marshals \u0026#34;v\u0026#34; by returning the body bytes if v is a // google.api.HttpBody message, otherwise it falls back to the default Marshaler. func (h *HTTPBodyMarshaler) Marshal(v interface{}) ([]byte, error) { if httpBody, ok := v.(*httpbody.HttpBody); ok { return httpBody.Data, nil } return h.Marshaler.Marshal(v) } // no Delimiter for httpbody func (j *HTTPBodyMarshaler) Delimiter() []byte { return []byte{} }   "});index.add({'id':20,'href':'/docs/overview/extensions/extension_proto/','title':"Protobuf Extension",'section':"Extensions",'content':"The Protobuf Extension #  The protobuf extension is meanwhile a fix part of the specs and Furo.\nIn this, meanwhile built in, extesnion you define things for the protos.\n__proto extension in a type #  The proto extension in a type defines the package, target file, imports (*.proto) and options\n1 2 3 4 5 6 7 8 9  __proto:package:authtargetfile:auth.protoimports:[]options:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseauth  __proto extension in a field of a type #  The proto extension in a field let you define the field id an can set a oneof group.\n1 2 3 4 5 6 7 8  fields:id:type:stringdescription:The identifier.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:null  __proto extension in a service #  The proto extension in a service defines the package, target file, imports (*.proto) and options\n1 2 3 4 5 6 7 8 9 10 11 12 13  __proto:package:Services.authtargetfile:auth.protoimports:- google/api/annotations.proto- Services/auth/reqmsgs.proto- google/protobuf/empty.proto- auth/auth.protooptions:go_package:github.com/veith/doit-specs/dist/pb/Services/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseServices.auth  "});index.add({'id':21,'href':'/docs/overview/extensions/extension_ui/','title':"UI Extension",'section':"Extensions",'content':"__ui extension #  Define some options for the ui-builder (furoc-gen-u33e).\n____ui extension in a field of a type #  1 2 3 4 5 6 7 8 9 10 11  fields:id:type:stringdescription:The identifier.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:component:\u0026#34;furo-data-text-input\u0026#34;flags:[]no_init:false  "});index.add({'id':22,'href':'/docs/overview/extensions/','title':"Extensions",'section':"Overview",'content':"Extensionpoints #  In the past, extensions were added by adding a field to a spec, using \u0026ldquo;__\u0026rdquo; as prefix. This was no problem, as long the complete build chain was js based, everyone could add his extension to the spec. Adding your custom extensions is still supported, but they have to go to the field extensions. Extensionpoints are available for types, fields in types, services and methods in services. The __proto and __ui extensions were so broadly used, that they become a fix part of the specs.\nExtensions can have any structure and can be used in furoc generator plugins or a scripts that consumes furo exportAsYaml -f, which is nearly the same structure a furoc generator would receive.\nExtension are only available in the standard spec notation. You can not use them in µSpecs.  Extensions in a service #  1 2 3 4 5 6 7 8 9 10 11  name:FruitServiceextensions:dummy:corename:fruitsgen:golangmethods:ListFruits:description:List fruits with pagination.extensions:otherextension:- fast  Extensions in a type #  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41  name:Credentialstype:Credentialsdescription:Credentials type for login.__proto:package:authtargetfile:auth.protoimports:[]options:go_package:github.com/veith/doit-specs/dist/pb/auth;authpbjava_multiple_files:\u0026#34;true\u0026#34;java_outer_classname:AuthProtojava_package:com.furo.baseauthfields:password:type:stringdescription:The password.__proto:number:1oneof:\u0026#34;\u0026#34;__ui:nullmeta:default:\u0026#34;\u0026#34;hint:\u0026#34;\u0026#34;label:auth.Credentials.password.labeloptions:flags:[]list:[]readonly:falserepeated:falsetypespecific:nullconstraints:required:is:\u0026#34;true\u0026#34;message:password is requiredextensions:#\u0026lt;-- field extensionsdummyextension:key:a field extensionextensions:#\u0026lt;-- type extensionsdummyextension:key:a type extension  "});index.add({'id':23,'href':'/docs/overview/style_guide/','title':"Style Guide",'section':"Overview",'content':"Style Guide #  The style guide is nearly similar to the protocol buffers style guide and follows also the google api design guidelines.\nFile structure #  Files should be named lower_snake_case.types.yaml.\nYou can put the services and types to the same folder (thematic group). You can move the files around without any effect. The resulting protos does not depend on the FIDL file names or structure, they will follow the given package definitions.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  muspecs ├── auth │ ├── auth.services.yaml │ └── auth.types.yaml └── fruits ├── fruit.services.yaml └── fruits.types.yaml dist/protos ├── Services │ └── auth │ ├── auth.proto │ └── reqmsgs.proto ├── auth │ └── auth.proto └── fruit ├── fruit.proto ├── fruitservice.proto └── reqmsgs.proto   Type and field names #  package names #  Use camelCase (without an initial capital) for package names.\nsample.SampleRequest  type names #  Use CamelCase (with an initial capital) for type names.\nsample.SampleRequest  field names #  Use underscore_separated_names for field names for example, birth_date.\nbirth_date  1 2 3 4 5  - type:\u0026#39;sample.Sample #A sample type\u0026#39;fields:password:\u0026#39;* string:1 #The password.\u0026#39;birth_date:\u0026#39;* google.type.Date:2 #The username or email, or something to identify.\u0026#39;details:\u0026#39;sample.Details:3 #Details.\u0026#39;  If your field name contains a number, the number should appear after the letter instead of after the underscore. e.g., use song_name1 instead of song_name_1\nRepeated fields #  Use pluralized names for repeated fields.\ntags: \u0026lsquo;[] string:1 #Some tags.\u0026rsquo;  Services #  You should use CamelCase (with an initial capital) for both the service name and any method names:\nLook at - name: FruitService , - md: \u0026lsquo;ListFruits: GET /\u0026hellip;. You can find a good guide and explanation on the Standard Methods page of the cloud API design guide page.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  - name:FruitServicedescription:|Fruits are healthy, so having a service which can list some fruits would be nice. We do not cover all fruits, but some. The list will grow with time, hopefully.package:fruittarget:fruit_service.protomethods:- md: \u0026#39;ListFruits:GET /fruits google.protobuf.Empty , fruit.FruitCollection#Filterable and searchable list of fruits with pagination.\u0026#39;qp:q:\u0026#39;string #Use this to search for a fruit.\u0026#39;filter:\u0026#39;string #Use this field to filter the fruits, this is not searching.\u0026#39;order_by:\u0026#39;string #Use this field to specify the ordering.\u0026#39;page:\u0026#39;string #Use this field to specify page to display.\u0026#39;- md: \u0026#39;Get:GET /fruits/{frt} google.protobuf.Empty , fruit.FruitEntity#Returns a single fruit.\u0026#39;qp:frt:\u0026#39;string #The query param frt stands for the FRuiT id.\u0026#39;  URL Path #  Usualy the path part is a noun in plural form. Use singular nouns only on singleton ressources. Do not append a prefix like /api to your paths. Use /fruits.\nTIPP: Assume that your API is a host by its own. So you will address it with api.xy.com/fruits. Having api.xy.com/api/fruits will look strange in that moment.\nAdding prefixes can be done by infrastructure. The furo client libs also have the posibillity to prefix your specs according to the situation.\n You will loose portability capabilities when you prefix your paths.  URL Placeholer / Query Params #  Use short names for the placeholders because they will apear on every request you make and also in the HATEOAS of every response.\nUse some consonants only and use them that you can recognize the word behind, when possible. The first letter of a word is allowed to be a vovel.\nMain objects of your domain should use only two or three letters. A\nq is \u0026ldquo;reserved\u0026rdquo; for search query.  some examples\n fruit =\u0026gt; frt example_data =\u0026gt; exd support_cases spc support_analysis spa  "});index.add({'id':24,'href':'/posts/placeholder/','title':"Placeholder",'section':"Blog",'content':" Field placeholder in fieldmetas added.\n"});index.add({'id':25,'href':'/posts/stream/','title':"Streaming support added",'section':"Blog",'content':"We support the definition of streaming resources as responses now. Read more about it\n"});index.add({'id':26,'href':'/posts/hello/','title':"Initial documentation",'section':"Blog",'content':"Initial documentation #  Hi and welcome to the first version of the FIDL documentation. If you have some issues, found typos and have suggestions, feel free to open an issue or better make a pull request.\n"});})();